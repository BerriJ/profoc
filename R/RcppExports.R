# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Probabilistic Forecast Combination - Batch
#'
#' Returns predictions and weights calculated by online-learning algorithms
#' using CRPS Learning. By default, the weights are calculated by
#' gradient based bernstein online aggregation (BOAG).
#'
#' @param y A numeric vector of realizations.
#' @param experts A an array of predictions with dimension
#' (Observations, Quantiles, Experts).
#' @param tau A numeric vector of probabilities.
#' corresponding to the columns of experts.
#' @param loss_function Either "quantile", "expectile" or "percentage".
#' @param loss_parameter Optional parameter scaling the power of the loss function.
#' @param ex_post_smooth Determines if smoothing is during or after
#' online-learning. If true, contemporary weights are not affected
#' but output weights are. If false (default) smoothed weights are
#' also by the algorithm.
#' @param ex_post_fs Analogous to ex_post_smooth: shall a fixed-share
#' be added during (FALSE) or after online-learning (TRUE).
#' @param lambda Penalization parameter used in the smoothing Step.
#' -Inf causes the smoothing step to be skipped (default).
#' @param method One of "boa", "ml_poly" or "ewa".
#' @param method_var Allows to calculate slight variations of the BOA
#' algorithm
#' @param forget_regret Share of past regret not to be considered, resp. to be
#' forgotten in every iteration of the algorithm. Defaults to 0.
#' @param forget_performance Share of past performance not to be considered, resp. to be
#' forgotten in every iteration of the algorithm when choosing the parameter combination. Defaults to 0.
#' @param fixed_share Amount of fixed share to be added to the weights.
#' Defaults to 0. 1 leads to uniform weights.
#' @param gamma Scaling parameter for the learning rate.
#' @param ndiff Degree of the differencing operator in the smoothing equation. 1 (default) leads to shrikage towards a constant. Can also be 2 or any value in between. If a value in between is used, a weighted sum of the first and second differentiation matrix is calculated.
#' @param deg Degree of the B-Spine basis functions.
#' @param knot_distance determines the distance of the knots. Defaults to 0.025 which corrsponds to the grid steps when knot_distance_power = 1 (the default).
#' @param knot_distance_power Parameter which defining the symetrie of the b-spline basis. Defaults to 1 which corresponds to the equidistant case. Values less than 1 create more knots in the center while values above 1 concentrate more knots in the tails.
#' @param gradient Determines if a linearized version of the loss is used.
#' @param loss_array User specified loss array. If specified, the loss will not be calculated by profoc.
#' @param regret_array User specified regret array. If specifiec, the regret will not be calculated by profoc.
#' @param trace If a progessbar shall be printed. Defaults to TRUE.
#' @param init_weights Matrix of dimension Kx1 or KxP used as starting weights. Kx1 represents the constant solution with equal weights over all P whereas specifiying a KxP matrix allows different starting weights for each P.
#' @param lead_time offset for expert forecasts. Defaults to 0, which means that
#' experts forecast t+1 at t. Setting this to h means experts predictions refer
#' to t+1+h at time t. The weight updates delay accordingly.
#' @param allow_quantile_crossing Shall quantile crossing be allowed? Defaults to false which means that predictions are sorted in ascending order.
#' @usage profoc(y, experts, tau, loss_function = "quantile",
#' loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE,
#' lambda = -Inf, method = "boa", method_var = "A", forget_regret = 0,
#' forget_performance = 0, fixed_share = 0, gamma = 1, ndiff = 1, deg = 3,
#' knot_distance = 0.025, knot_distance_power = 1,
#' gradient = TRUE, loss_array = NULL, regret_array = NULL,
#' trace = TRUE, init_weights = NULL, lead_time = 0, allow_quantile_crossing = FALSE)
#' @return Batch can tune various parameters automatically based on
#' the past loss. For this, lambda, forget, fixed_share, gamma, ndiff,
#' deg and knot_distance can be specified as numeric vectors containing
#' parameters to consider. Batch will automatically try all possible
#' combinations of values provide.
#' @export
batch <- function(y, experts, tau = as.numeric( c()), expanding_window = TRUE, convex_constraint = FALSE, initial_window = 30L, loss_function = "quantile", loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE, lambda = as.numeric( c()), forget_regret = as.numeric( c()), forget_performance = 0, fixed_share = as.numeric( c()), gamma = as.numeric( c()), ndiff = as.numeric( c()), deg = as.numeric( c()), knot_distance = as.numeric( c()), knot_distance_power = as.numeric( c()), trace = TRUE, init_weights = NULL, lead_time = 0L, allow_quantile_crossing = FALSE) {
    .Call(`_profoc_batch`, y, experts, tau, expanding_window, convex_constraint, initial_window, loss_function, loss_parameter, ex_post_smooth, ex_post_fs, lambda, forget_regret, forget_performance, fixed_share, gamma, ndiff, deg, knot_distance, knot_distance_power, trace, init_weights, lead_time, allow_quantile_crossing)
}

loss <- function(y, x, pred = 0, method = "quantile", tau = 0.5, a = 1, gradient = TRUE) {
    .Call(`_profoc_loss`, y, x, pred, method, tau, a, gradient)
}

loss_grad_wrt_w <- function(expert, pred, truth, tau, loss_function, a, w) {
    .Call(`_profoc_loss_grad_wrt_w`, expert, pred, truth, tau, loss_function, a, w)
}

pmin_arma <- function(x, bound) {
    .Call(`_profoc_pmin_arma`, x, bound)
}

pmax_arma <- function(x, bound) {
    .Call(`_profoc_pmax_arma`, x, bound)
}

diff_cpp <- function(x, lag, differences) {
    .Call(`_profoc_diff_cpp`, x, lag, differences)
}

get_combinations <- function(x, y) {
    .Call(`_profoc_get_combinations`, x, y)
}

set_default <- function(input, value) {
    .Call(`_profoc_set_default`, input, value)
}

#' Probabilistic Forecast Combination - Online
#'
#' Returns predictions and weights calculated by online-learning algorithms
#' using CRPS Learning. By default, the weights are calculated by
#' gradient based bernstein online aggregation (BOAG).
#'
#' @param y A numeric vector of realizations.
#' @param experts A an array of predictions with dimension
#' (Observations, Quantiles, Experts).
#' @param tau A numeric vector of probabilities.
#' corresponding to the columns of experts.
#' @param loss_function Either "quantile", "expectile" or "percentage".
#' @param loss_parameter Optional parameter scaling the power of the loss function.
#' @param ex_post_smooth Determines if smoothing is during or after
#' online-learning. If true, contemporary weights are not affected
#' but output weights are. If false (default) smoothed weights are
#' also by the algorithm.
#' @param ex_post_fs Analogous to ex_post_smooth: shall a fixed-share
#' be added during (FALSE) or after online-learning (TRUE).
#' @param lambda Penalization parameter used in the smoothing Step.
#' -Inf causes the smoothing step to be skipped (default).
#' @param method One of "boa", "ml_poly" or "ewa".
#' @param method_var Allows to calculate slight variations of the BOA
#' algorithm
#' @param forget_regret Share of past regret not to be considered, resp. to be
#' forgotten in every iteration of the algorithm. Defaults to 0.
#' @param forget_performance Share of past performance not to be considered, resp. to be
#' forgotten in every iteration of the algorithm when choosing the parameter combination. Defaults to 0.
#' @param fixed_share Amount of fixed share to be added to the weights.
#' Defaults to 0. 1 leads to uniform weights.
#' @param gamma Scaling parameter for the learning rate.
#' @param ndiff Degree of the differencing operator in the smoothing equation. 1 (default) leads to shrikage towards a constant. Can also be 2 or any value in between. If a value in between is used, a weighted sum of the first and second differentiation matrix is calculated.
#' @param deg Degree of the B-Spine basis functions.
#' @param knot_distance determines the distance of the knots. Defaults to 0.025 which corrsponds to the grid steps when knot_distance_power = 1 (the default).
#' @param knot_distance_power Parameter which defining the symetrie of the b-spline basis. Defaults to 1 which corresponds to the equidistant case. Values less than 1 create more knots in the center while values above 1 concentrate more knots in the tails.
#' @param gradient Determines if a linearized version of the loss is used.
#' @param loss_array User specified loss array. If specified, the loss will not be calculated by profoc.
#' @param regret_array User specified regret array. If specifiec, the regret will not be calculated by profoc.
#' @param trace If a progessbar shall be printed. Defaults to TRUE.
#' @param init_weights Matrix of dimension Kx1 or KxP used as starting weights. Kx1 represents the constant solution with equal weights over all P whereas specifiying a KxP matrix allows different starting weights for each P.
#' @param lead_time offset for expert forecasts. Defaults to 0, which means that
#' experts forecast t+1 at t. Setting this to h means experts predictions refer
#' to t+1+h at time t. The weight updates delay accordingly.
#' @param allow_quantile_crossing Shall quantile crossing be allowed? Defaults to false which means that predictions are sorted in ascending order.
#' @usage online(y, experts, tau, loss_function = "quantile",
#' loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE,
#' lambda = -Inf, method = "boa", method_var = "A", forget_regret = 0,
#' forget_performance = 0, fixed_share = 0, gamma = 1, ndiff = 1, deg = 3,
#' knot_distance = 0.025, knot_distance_power = 1,
#' gradient = TRUE, loss_array = NULL, regret_array = NULL,
#' trace = TRUE, init_weights = NULL, lead_time = 0, allow_quantile_crossing = FALSE)
#' @return online can tune various parameters automatically based on
#' the past loss. For this, lambda, forget, fixed_share, gamma, ndiff,
#' deg and knot_distance can be specified as numeric vectors containing
#' parameters to consider. online will automatically try all possible
#' combinations of values provide.
#' @export
online <- function(y, experts, tau = as.numeric( c()), loss_function = "quantile", loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE, lambda = as.numeric( c()), method = "boa", method_var = "A", forget_regret = as.numeric( c()), forget_performance = 0, fixed_share = as.numeric( c()), gamma = as.numeric( c()), ndiff = as.numeric( c()), deg = as.numeric( c()), knot_distance = as.numeric( c()), knot_distance_power = as.numeric( c()), gradient = TRUE, loss_array = as.numeric( c()), regret_array = as.numeric( c()), trace = TRUE, init_weights = NULL, lead_time = 0L, allow_quantile_crossing = FALSE) {
    .Call(`_profoc_online`, y, experts, tau, loss_function, loss_parameter, ex_post_smooth, ex_post_fs, lambda, method, method_var, forget_regret, forget_performance, fixed_share, gamma, ndiff, deg, knot_distance, knot_distance_power, gradient, loss_array, regret_array, trace, init_weights, lead_time, allow_quantile_crossing)
}

optimize_weights <- function(initvals, truth, experts, convex_constraint = FALSE, loss_function = "quantile", tau = 0.5, loss_scaling = 1) {
    .Call(`_profoc_optimize_weights`, initvals, truth, experts, convex_constraint, loss_function, tau, loss_scaling)
}

oracle <- function(y, experts, tau = as.numeric( c()), loss_function = "quantile", loss_parameter = 1, convex_constraint = FALSE) {
    .Call(`_profoc_oracle`, y, experts, tau, loss_function, loss_parameter, convex_constraint)
}

make_knots <- function(kstep, a = 1, deg = 3L) {
    .Call(`_profoc_make_knots`, kstep, a, deg)
}

make_difference_matrix <- function(knots, bdiff, deg) {
    .Call(`_profoc_make_difference_matrix`, knots, bdiff, deg)
}

make_hat_matrix <- function(x, kstep, lambda, bdiff, deg, a) {
    .Call(`_profoc_make_hat_matrix`, x, kstep, lambda, bdiff, deg, a)
}

spline_fit <- function(y, x, lambda = 1, ndiff = 1L, deg = 3L, knot_distance = 0.1, knot_distance_power = 1) {
    .Call(`_profoc_spline_fit`, y, x, lambda, ndiff, deg, knot_distance, knot_distance_power)
}

splines2_basis <- function(x, knots, deg, boundary_knots) {
    .Call(`_profoc_splines2_basis`, x, knots, deg, boundary_knots)
}

