# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @template function_batch
#'
#' @template param_y
#' @template param_experts
#' @template param_tau
#' @template param_affine
#' @template param_positive
#' @template param_intercept
#' @template param_debias
#' @param initial_window Defines the size of the initial estimaton window.
#' @param expanding_window Defines wether an expanding window or a rolling window shall be used for batch optimization. Defaults to TRUE.
#' @template param_loss_function
#' @template param_loss_parameter
#' @template param_lambda
#' @template param_forget
#' @template param_forget_performance
#' @template param_fixed_share
#' @template param_ndiff
#' @template param_deg
#' @template param_basis_deg
#' @template param_knot_distance
#' @template param_basis_knot_distance
#' @template param_knot_distance_power
#' @template param_basis_knot_distance_power
#' @template param_trace
#' @template param_lead_time
#' @template param_allow_quantile_crossing
#' @template param_soft_threshold
#' @template param_hard_threshold
#' @usage batch(y, experts, tau, affine = FALSE, positive = FALSE, intercept = FALSE,
#' debias = TRUE, initial_window = 30, expanding_window = TRUE,
#' loss_function = "quantile", loss_parameter = 1, lambda = -Inf,
#' forget = 0, forget_performance = 0, fixed_share = 0, ndiff = 1, deg = 3,
#' basis_deg = 3, knot_distance = 0.1, basis_knot_distance = 0.1,
#' knot_distance_power = 1, basis_knot_distance_power = 1, trace = TRUE, lead_time = 0,
#' allow_quantile_crossing = FALSE, soft_threshold = -Inf, hard_threshold = -Inf)
#' @export
batch <- function(y, experts, tau = as.numeric( c()), affine = FALSE, positive = FALSE, intercept = FALSE, debias = TRUE, initial_window = 30L, expanding_window = TRUE, loss_function = "quantile", loss_parameter = 1, lambda = as.numeric( c(-1 / 0)), forget = as.numeric( c(0)), forget_performance = 0, fixed_share = as.numeric( c(0)), ndiff = as.numeric( c(1.5)), deg = as.numeric( c(3)), basis_deg = as.numeric( c()), knot_distance = as.numeric( c(0.1)), basis_knot_distance = as.numeric( c()), knot_distance_power = as.numeric( c(1)), basis_knot_distance_power = as.numeric( c()), trace = TRUE, lead_time = 0L, allow_quantile_crossing = FALSE, soft_threshold = as.numeric( c(-1 / 0)), hard_threshold = as.numeric( c(-1 / 0))) {
    .Call(`_profoc_batch`, y, experts, tau, affine, positive, intercept, debias, initial_window, expanding_window, loss_function, loss_parameter, lambda, forget, forget_performance, fixed_share, ndiff, deg, basis_deg, knot_distance, basis_knot_distance, knot_distance_power, basis_knot_distance_power, trace, lead_time, allow_quantile_crossing, soft_threshold, hard_threshold)
}

loss <- function(y, x, pred = 0, method = "quantile", tau = 0.5, a = 1, gradient = TRUE) {
    .Call(`_profoc_loss`, y, x, pred, method, tau, a, gradient)
}

loss_grad_wrt_w <- function(expert, pred, truth, tau, loss_function, a, w) {
    .Call(`_profoc_loss_grad_wrt_w`, expert, pred, truth, tau, loss_function, a, w)
}

pmin_arma <- function(x, bound) {
    .Call(`_profoc_pmin_arma`, x, bound)
}

pmax_arma <- function(x, bound) {
    .Call(`_profoc_pmax_arma`, x, bound)
}

diff_cpp <- function(x, lag, differences) {
    .Call(`_profoc_diff_cpp`, x, lag, differences)
}

get_combinations <- function(x, y) {
    .Call(`_profoc_get_combinations`, x, y)
}

set_default <- function(input, value) {
    .Call(`_profoc_set_default`, input, value)
}

vec2mat <- function(x, matrows, matcols) {
    .Call(`_profoc_vec2mat`, x, matrows, matcols)
}

mat2vec <- function(x) {
    .Call(`_profoc_mat2vec`, x)
}

#' @template function_online
#'
#' @template param_y
#' @template param_experts
#' @template param_tau
#' @template param_intercept
#' @template param_loss_function
#' @template param_loss_parameter
#' @template param_ex_post_smooth
#' @template param_ex_post_fs
#' @template param_lambda
#' @template param_method
#' @param method_var Allows to calculate slight variations of the BOA
#' algorithm
#' @param forget_regret Share of past regret not to be considered, resp. to be
#' forgotten in every iteration of the algorithm. Defaults to 0.
#' @template param_forget_performance
#' @template param_fixed_share
#' @param gamma Scaling parameter for the learning rate.
#' @template param_ndiff
#' @template param_deg
#' @template param_basis_deg
#' @template param_knot_distance
#' @template param_basis_knot_distance
#' @template param_knot_distance_power
#' @template param_basis_knot_distance_power
#' @param gradient Determines if a linearized version of the loss is used.
#' @param loss_array User specified loss array. If specified, the loss will not be calculated by profoc.
#' @param regret_array User specified regret array. If specifiec, the regret will not be calculated by profoc.
#' @template param_trace
#' @param init_weights Matrix of dimension Kx1 or KxP used as starting weights. Kx1 represents the constant solution with equal weights over all P whereas specifiying a KxP matrix allows different starting weights for each P.
#' @template param_lead_time
#' @template param_allow_quantile_crossing
#' @template param_soft_threshold
#' @template param_ex_post_soft_threshold
#' @template param_hard_threshold
#' @template param_ex_post_hard_threshold
#' @usage online(y, experts, tau, intercept = FALSE, loss_function = "quantile",
#' loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE,
#' lambda = -Inf, method = "boa", method_var = "A", forget_regret = 0,
#' forget_performance = 0, fixed_share = 0, gamma = 1, ndiff = 1, deg = 3,
#' basis_deg = 3, knot_distance = 0.1, basis_knot_distance = 0.1,
#' knot_distance_power = 1, basis_knot_distance_power = 1,
#' gradient = TRUE, loss_array = NULL, regret_array = NULL,
#' trace = TRUE, init_weights = NULL, lead_time = 0, allow_quantile_crossing = FALSE,
#' soft_threshold = -Inf, ex_post_soft_threshold = FALSE, hard_threshold = -Inf,
#' ex_post_hard_threshold = FALSE)
#' @export
online <- function(y, experts, tau = as.numeric( c()), intercept = FALSE, loss_function = "quantile", loss_parameter = 1, ex_post_smooth = FALSE, ex_post_fs = FALSE, lambda = as.numeric( c(-1 / 0)), method = "boa", method_var = "A", forget_regret = as.numeric( c(0)), forget_performance = 0, fixed_share = as.numeric( c(0)), gamma = as.numeric( c(1)), ndiff = as.numeric( c(1.5)), deg = as.numeric( c(3)), basis_deg = as.numeric( c()), knot_distance = as.numeric( c(0.1)), basis_knot_distance = as.numeric( c()), knot_distance_power = as.numeric( c(1)), basis_knot_distance_power = as.numeric( c()), gradient = TRUE, loss_array = as.numeric( c()), regret_array = as.numeric( c()), trace = TRUE, init_weights = NULL, lead_time = 0L, allow_quantile_crossing = FALSE, soft_threshold = as.numeric( c(-1 / 0)), ex_post_soft_threshold = FALSE, hard_threshold = as.numeric( c(-1 / 0)), ex_post_hard_threshold = FALSE) {
    .Call(`_profoc_online`, y, experts, tau, intercept, loss_function, loss_parameter, ex_post_smooth, ex_post_fs, lambda, method, method_var, forget_regret, forget_performance, fixed_share, gamma, ndiff, deg, basis_deg, knot_distance, basis_knot_distance, knot_distance_power, basis_knot_distance_power, gradient, loss_array, regret_array, trace, init_weights, lead_time, allow_quantile_crossing, soft_threshold, ex_post_soft_threshold, hard_threshold, ex_post_hard_threshold)
}

optimize_weights <- function(truth, experts, affine = FALSE, positive = FALSE, intercept = FALSE, debias = TRUE, loss_function = "quantile", tau = 0.5, forget = 0, loss_scaling = 1) {
    .Call(`_profoc_optimize_weights`, truth, experts, affine, positive, intercept, debias, loss_function, tau, forget, loss_scaling)
}

optimize_weights2 <- function(truth, experts, affine, positive, intercept, debias, loss_function, tau_vec, forget, loss_scaling, basis, beta) {
    .Call(`_profoc_optimize_weights2`, truth, experts, affine, positive, intercept, debias, loss_function, tau_vec, forget, loss_scaling, basis, beta)
}

#' @template function_oracle
#'
#' @template param_y
#' @template param_experts
#' @template param_tau
#' @template param_affine
#' @template param_positive
#' @template param_intercept
#' @template param_debias
#' @template param_loss_function
#' @template param_loss_parameter
#' @template param_forget
#' @usage oracle(y, experts, tau, affine = FALSE,
#' positive = FALSE, intercept = FALSE, debias = TRUE,
#' loss_function = "quantile", loss_parameter = 1, forget = 0)
#' @export
oracle <- function(y, experts, tau = as.numeric( c()), affine = FALSE, positive = FALSE, intercept = FALSE, debias = TRUE, loss_function = "quantile", loss_parameter = 1, forget = 0) {
    .Call(`_profoc_oracle`, y, experts, tau, affine, positive, intercept, debias, loss_function, loss_parameter, forget)
}

make_knots <- function(kstep, a = 1, deg = 3L) {
    .Call(`_profoc_make_knots`, kstep, a, deg)
}

make_difference_matrix <- function(knots, bdiff, deg) {
    .Call(`_profoc_make_difference_matrix`, knots, bdiff, deg)
}

make_hat_matrix <- function(x, kstep, lambda, bdiff, deg, a) {
    .Call(`_profoc_make_hat_matrix`, x, kstep, lambda, bdiff, deg, a)
}

make_basis_matrix <- function(x, kstep, deg, a) {
    .Call(`_profoc_make_basis_matrix`, x, kstep, deg, a)
}

spline_fit <- function(y, x, lambda = 1, ndiff = 1L, deg = 3L, knot_distance = 0.1, knot_distance_power = 1) {
    .Call(`_profoc_spline_fit`, y, x, lambda, ndiff, deg, knot_distance, knot_distance_power)
}

splines2_basis <- function(x, knots, deg, boundary_knots) {
    .Call(`_profoc_splines2_basis`, x, knots, deg, boundary_knots)
}

