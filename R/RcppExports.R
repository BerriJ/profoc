# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Probabilistic Forecast Combination - ProFoC
#'
#' Returns predictions and weights calculated by online-learning algorithms
#' using CRPS Learning. By default, the weights are calculated by
#' gradient based bernstein online aggregation (BOAG).
#'
#' @param y A numeric vector of realizations.
#' @param experts A an array of predictions with dimension
#' (Observations, Quantiles, Experts).
#' @param tau A numeric vector of probabilities.
#' corresponding to the columns of experts.
#' @param ex_post_smooth Determines if smoothing is during or after
#' online-learning. If true, contemporary weights are not affected
#' but output weights are. If false (default) smoothed weights are
#' also by the algorithm.
#' @param ex_post_fs Analogous to ex_post_smooth: shall a fixed-share
#' be added during (FALSE) or after online-learning (TRUE).
#' @param lambda Penalization parameter used in the smoothing Step.
#' -Inf causes the smoothing step to be skipped (default).
#' @param method One of "boa", "ml_poly" or "ewa".
#' @param method_var Allows to calculate slight variations of the BOA
#' algorithm
#' @param forget_regret Share of past regret not to be considered, resp. to be
#' forgotten in every iteration of the algorithm. Defaults to 0.
#' @param forget_performance Share of past performance not to be considered, resp. to be
#' forgotten in every iteration of the algorithm when choosing the parameter combination. Defaults to 0.
#' @param fixed_share Amount of fixed share to be added to the weights.
#' Defaults to 0. 1 leads to uniform weights.
#' @param gamma Scaling parameter for the learning rate.
#' @param ndiff Degree of the differencing operator in the smoothing equation. 1 (default) leads to shrikage towards a constant.
#' @param deg Degree of the B-Spine basis functions.
#' @param rel_nseg determines how many basis functions are created in the smoothing step. This parameter defaults to 0.5 leading to 0.5*length(tau) to be used as number of knots. 1 Leads to as many knots as tau is long. 0 leads to one single knot.
#' @param gradient Determines if a linearized version of the loss is used.
#' @param loss_array User specified loss array. If specified, the loss will not be calculated by profoc.
#' @param regret_array User specified regret array. If specifiec, the regret will not be calculated by profoc.
#' @param trace If a progessbar shall be printed. Defaults to TRUE.
#' @param init_weights Matrix of dimension Kx1 or KxP used as starting weights. Kx1 represents the constant solution with equal weights over all P whereas specifiying a KxP matrix allows different starting weights for each P.
#' @usage profoc(y, experts, tau, ex_post_smooth = FALSE, ex_post_fs = FALSE,
#' lambda = -Inf, method = "boa", method_var = "A", forget_regret = 0,
#' forget_performance = 0, fixed_share = 0, gamma = 1, ndiff = 1, deg = 3,
#'rel_nseg = 0.5, gradient = TRUE, loss_array = NULL, regret_array = NULL,
#' trace = TRUE,
#' init_weights = NULL)
#' @return Profoc can tune various parameters automatically based on
#' the past loss. For this, lambda, forget, fixed_share, gamma, ndiff,
#' deg and rel_nseg can be specified as numeric vectors containing
#' parameters to consider. Profoc will automatically try all possible
#' combinations of values provide.
#' @export
profoc <- function(y, experts, tau = as.numeric( c()), ex_post_smooth = FALSE, ex_post_fs = FALSE, lambda = as.numeric( c()), method = "boa", method_var = "A", forget_regret = as.numeric( c()), forget_performance = 0, fixed_share = as.numeric( c()), gamma = as.numeric( c()), ndiff = as.numeric( c()), deg = as.numeric( c()), rel_nseg = as.numeric( c()), gradient = TRUE, loss_array = as.numeric( c()), regret_array = as.numeric( c()), trace = TRUE, init_weights = NULL) {
    .Call(`_profoc_profoc`, y, experts, tau, ex_post_smooth, ex_post_fs, lambda, method, method_var, forget_regret, forget_performance, fixed_share, gamma, ndiff, deg, rel_nseg, gradient, loss_array, regret_array, trace, init_weights)
}

#' Spline Fit - Fit Penalized B-Splines
#'
#' Returns fitted values.
#'
#' @param y The respones variable. Must be a numeric vector.
#' @param x Explanatory variable. Must be a numeric vector.
#' @param lambda The penalization parameter.
#' @param ndiff Degree of the difference operator to use when calculating
#' the B-Spline basis. A value of 1 corresponds to shrinkage towards
#' a constant, 2 corresponds to shrinkage towards a linear relationship
#' between x and y.
#' @param deg the degree of the basis functions.
#' @param rel_nseg The number of basis functions are calculated relative to the
#' length of y. A value of 0 corresponds to only 1 knot. A value of 1
#' corresponds to length(y) knots.
#' @export
spline_fit <- function(y, x, lambda = 1, ndiff = 1L, deg = 3L, rel_nseg = 0.1) {
    .Call(`_profoc_spline_fit`, y, x, lambda, ndiff, deg, rel_nseg)
}

